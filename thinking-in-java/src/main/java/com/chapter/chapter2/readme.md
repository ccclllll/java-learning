### 一切皆是对象
1. java运行时的存储问题 (在ram中运行)
    * 寄存器：
    * 堆栈：堆栈一般存放对象的引用 通过变量名找到引用(引用的某块空间，是一个地址，这个地址指向实际的对象)，然后通过引用找到实际的对象。
    * 堆：用于存放所有的java对象
    * 常量的存储： 放到程序代码内部
    * 非ram存储： 一般是流对象和持久化对象(存储在磁盘中的对象)
    * 基本类型的存储： 基本类型是一个很小的变量，基本类型的存储是直接将值直接存放在堆栈中。
    所以基本类型不需要通过引用去找到对象，而是通过变量名直接找到了值。
2. java中的高精度数字
     * BigInteger 支持任意精度的整数
     * BigDecimal 支持任意精度的定点数
     *(注)两者都属于包装类型，和int float 对应，操作方法相似。*
3. 对象的生命周期
    * 对象的作用域：举两个例子。
      ```java
         {int i =1; { int x =99; // Illefal}}
      ```
       error 变量已经定义 所以java中的对象的引用可以
    存活在作用域之外。
       ```java
          {{String s = new String("a string");} String s2 =s} // error 
       ```
   ***
   由此可见，大范围的作用域会传递到小范围的作用域，而小的作用域却不能传递到大范围的作用域。
    * 对象的销毁： 当对象不会再被引用的时候，会被java虚拟机的垃圾回收机制回收。
    
4. 关于static 关键字：  
使用了static关键字后，则表明这个域不会与类的实例相关联，所以即使这个类并没有实例，也可以访问  
这个static域。
5. 关于注释  
注释标签：
    * @see 表示引用其它类
    * @author 作者
    * @return 返回值
    * @vision 版本
    * @param 方法参数
    * @throws 抛出异常
    * @description 一长段描述 
    * ...

6. 引用和对象  
引用不是对象。对于表达式 A a = new A(); 变量a是一个引用，它存储的数据是对象所在的内存地址，new 关键字为A 的对象分配了内存空间，并执行了无参构造
方法。当执行 A b = new A();a = b 这段语句时，实际上是改变了a变量的数据区，原本数据区存放的是第一个new出来的A对象的地址,赋值
之后存放的是第二次new出来的a对象的地址。java中对一个对象的操作是通过变量找到其所在的存储单元的地址，然后再操纵存储单元的数据。对于基本类型，变量的数据区
存放的就是基本类型的值，所以不需要像访问对象一样，先找到地址，再去操纵对象，而是直接操纵数据。  
引用其实就是指针，但是指针可以被改变被改变用来改变地址。  
存储单元{地址，数据}---指针可以对地址进行操作，地址改变，相应的存储单元自然也改变。
指针{地址，数据}  
引用{地址，数据}
指针类似于不可改变地址的指针
```c
   int i=0;  
  // f是一个指针类型变量，用const修饰之后，f的地址不可再改变，但是数据可以改变 ，这就类似于引用，
  //对引用进行操作，之后改变数据区的值
  //（指针变量默认表示存储单元的地址，普通变量默认表示存储单元的数据）
   int* const  f = &i; 
   f++; // error 
   *f=i++; // ok
```
变量 表示的是一个存储单元，但是实际上显示给程序员的是存储单元的数据，指针变量其实也是一样，只不过指针变量数据区存储的是  
一个地址而已，C语言中可同通过*操作符取得地址的值。所以对于指针 int* p = &a; 指针变量的名字是p，p的数据是a的地址，通过*p就可以取得  
a地址存储的数据。
   
   



   
